# AI Agents UI Interface Documentation

## Overview

This project provides a user interface for interacting with AI agents. It includes various features, such as agent selection, chat, Github plug-in performing Git-hub actions: connecting to a repository, implementing new features, creating issues , as well as output visualization. This documentation will guide users through the functionality and usage of the interface.

![Eliza UI Interface](static/img/Eliza_UI_Interace.png)

---

## Table of Contents

1. [Getting Started](#getting-started)
2. [UI Components](#ui-components)
3. [Features](#features)
4. [Usage](#usage)
5. [Limitations](#limitations)


---

## Getting Started

### Accessing the Interface

The AI Agents UI can be accessed via the following URL:

- **[AI Agents UI Interface](https://eliza-dev.realityspiral.com/)**

Simply visit this link in your web browser to interact with the user interface. There is no need for local installation or setup; the interface is hosted and available for immediate use.

---

## Features

- **Agent Selection**: Select one of the Reality Spiral Agents and check their configuration, bio and lore.
- **Github Plug-in**: Ask agent to connect to a repository and perform Github actions: implement new features, create Issues, PRs.
- **Agent chat**: Interact with agent through the chat interface to get to know its personality, retreive information or perform certain queries and tasks.
- **Output Visualization**: View output generated by the AI agents in real time.

---

## UI Components

### 1. **Agent List**
   - Displays a list of available AI agents.
   - Each agent can be selected to configure its parameters.

### 2. **Settings Panel**
   - Shows agent settings, bio and lore. 
   - Will allow advanced mode in wich user will be able to connect to their private accounts for Github and Coinbase.

### 3. **Chat interface**
   - This interface allows interaction with agent through chat and display of agent performed actions.


### 4. **Status Indicators**
   - Shows if status is connected/disconnected
   

### 5. **Documentation**
   - Links to this user guide providing project information and agent usecases.


---

## Usage




### **Agent Use Cases**

The AI agents in this system can be used to automate tasks related to GitHub repository management, such as creating pull requests for implementing new features or refactoring code across a repository. Below are two specific use cases with corresponding prompts.

#### **Use Case 1: Refactoring Code Across the Repository**

Prompt Example:

User:

```plaintext
 "Implement replacing console.log with elizaLogger.log across the repo on repository user1/repo1 branch user1/demo against base develop."
```
Agent: 
```plaintext
"Pull request created successfully! URL: https://github.com/user1/repo1/demo/pull/1"
```
**Description:** This use case demonstrates an agent tasked with refactoring the code in a repository. The user specifies a task to replace all instances of console.log with elizaLogger.log across the user1/repo1 repository in the user1/demo branch. Once the agent processes the request, it creates a pull request with the proposed changes and returns a success message with the pull request URL.

**When to Use:** This agent can be used whenever you need to perform a global search-and-replace operation or apply a specific code refactor across an entire repository, automating the creation of the pull request and facilitating code review.
___
**Use Case 2: Implementing a Feature for an Issue**

Prompt Example:

User: 
```plaintext
"Implement feature for issue #42 in repository user1/repo1 branch demo against base demo."
```
Agent:
```plaintext
"Pull request created successfully! URL: https://github.com/user1/repo1/demo/pull/2"
```
**Description:** In this use case, the agent is tasked with implementing a feature related to a specific issue (e.g., issue #42). The user specifies the repository and branch where the feature should be developed. The agent then processes the request and creates a pull request with the necessary changes, including the reference to the issue being addressed. The agent responds with a success message along with the URL to the created pull request.

**When to Use:** This agent is useful when working on specific issues or feature requests in a repository. It automates the task of creating a pull request after implementing a feature and ensures that the correct branch and issue are referenced.
___
**Use Case 3: Creating a New Bug Report**

Prompt Example:

User: 
```plaintext
"Create an issue in repository user1/repo1 titled 'Bug: Application crashes on startup'."
```
Agent: 
```plaintext
"Created issue #1 successfully!"
```
**Description:** This use case highlights the agent's ability to create a new issue in a specified repository. For instance, the user reports a bug causing the application to crash on startup and provides details like the repository (user1/repo1) and issue title. The agent processes this request, creates the issue in the repository, and returns a success message with the issue number.

**When to Use:** This feature is useful for project management workflows, allowing developers or stakeholders to report bugs or tasks efficiently. The agent streamlines the issue creation process, ensuring consistency and accuracy in tracking work.
___

**Use Case 4: Branch Management**

Prompt Example:

User: 
```plaintext
"Create a new branch named feature/login-screen from main in the teamApp/frontend repository."
```
Agent: 
```plaintext
"Branch feature/login-screen created successfully in teamApp/frontend repository."
```
**Description:** In this use case, the agent facilitates branch creation for a repository. The user specifies the branch name (feature/login-screen), the base branch (main), and the repository (teamApp/frontend). The agent executes the request, creating the branch and confirming the success of the operation.

**When to Use:** This is particularly useful for managing feature branches or preparing for new development tasks. By automating branch creation, the agent saves time and ensures the branch structure adheres to specified naming conventions.
___
**Use Case 5: Committing Changes to a Repository**

Prompt Example 1:

User: 
```plaintext
"Commit changes to the repository user1/repo1 on branch 'main' with the commit message: 'Initial commit'."
```
Agent:
```plaintext
"Changes committed to repository user1/repo1 successfully to branch 'main'! Commit hash: abcdef1"
```
Prompt Example 2:

User:
```plaintext
"Create a commit in the repository user1/repo1 on branch 'main' with the commit message: 'Fix bug'."
```
Agent:
```plaintext
"Changes committed to repository user1/repo1 successfully to branch 'main'! Commit hash: abcdef3"
```
**Description:** This use case demonstrates the agent's ability to automate the process of committing changes to a specified repository and branch with a given commit message. Whether it's an initial commit, a README update, bug fix, feature addition, code refactor, or performance improvement, the agent ensures changes are applied to the desired branch and provides a confirmation message, including the unique commit hash for tracking purposes.The agent handles variations in wording and context (e.g., "create a commit" vs. "commit changes") while consistently delivering the desired outcome. It works seamlessly across repositories hosted on platforms like GitHub, with actions tailored to specific repository management systems (e.g., CREATE_COMMIT, GITHUB_COMMIT).

**When to Use:**

Version Control: Use the agent for adding or updating code changes to a repository in an efficient, automated manner.

Collaboration: Commit updates as part of a collaborative development process, enabling team members to stay up to date.

Consistency: Ensure that commits are properly structured with meaningful messages and accurately applied to the specified branch.

Automation: Ideal for CI/CD pipelines or scenarios requiring frequent, repetitive commits, reducing manual overhead.
___
**Use Case 6: Adding Comments to Issues**

Prompt Example 1:

User: 
```plaintext
"Add a comment to issue #1 in repository user1/repo1: 'This is fixed in the latest release'."
```
Agent:
```plaintext
"Added comment to issue #1 successfully! See comment at https://github.com/user1/repo1/issues/1#issuecomment-1234567890"
```
Prompt Example 2:

User:
```plaintext
"Add a comment to issue #2 in repository user2/repo2: 'Can you provide more details on this issue?'"
```
Agent:
```plaintext
"Added comment to issue #2 successfully! See comment at https://github.com/user2/repo2/issues/2#issuecomment-0987654321"
```
Prompt Example 3:

User:
```plaintext
"Add a comment to issue #3 in repository user3/repo3: 'We are working on a fix for this issue.'"
```
Agent:
```plaintext
"Added comment to issue #3 successfully! See comment at https://github.com/user3/repo3/issues/3#issuecomment-1122334455"
```
**Description:** This use case highlights the agent's ability to add comments to issues in a repository. The user specifies the issue number, repository, and the content of the comment. The agent processes the request, posts the comment to the issue, and provides a confirmation message that includes a direct link to the posted comment for reference.
This functionality supports various scenarios such as providing updates, requesting additional information, or tracking progress on issues, streamlining communication and collaboration within the repository.

**When to Use:** 

Collaboration: Use the agent to streamline communication and provide updates or clarifications on issues in repositories.

Project Tracking: Add comments to issues to document progress, decisions, or discussions.

Automation: Automate repetitive tasks such as posting templated responses or updating multiple issues, saving time and effort.

By leveraging this functionality, teams can ensure issues are well-documented, with clear and traceable discussions.
___
**Use Case 7: Modifying Issues**

Prompt Example 1:

User:
```plaintext
"Update issue #1 in repository user1/repo1 to add the label 'bug'."
```
Agent:
```plaintext
"Modified issue #1 successfully!"
```
**Description:** This use case highlights the agent's ability to modify an issues in a repository. The user specifies the issue number, repository, and the change. The agent processes the request, modifies the issue, and provides a confirmation message.

**When to Use:** Automation: Automate repetitive tasks such as modifying multiple issues.
___
**Use Case 8: Stop Actions**

Prompt Example 1:

User:
```plaintext
"Stop"
```
Agent:
```plaintext
"Stopped successfully!"
```
**Description:** This use case highlights the agent's ability to process a generic stop command without any specific context. When the user requests to "Stop," the agent halts its ongoing activity and confirms the action with a success message.

**When to Use:**
This is useful when users want to quickly interrupt or terminate an unspecified process, relying on the agent to determine the context and take appropriate action.

Prompt Example 2:

User:
```plaintext
"Stop the OODA loop"
```
Agent:
```plaintext
"OODA loop stopped successfully!"
```

**Description:** This use case demonstrates the agent’s capability to halt a specific process, in this case, the OODA loop (Observe, Orient, Decide, Act). The user specifies the OODA loop, and the agent processes the request to terminate it, returning a confirmation message.

**When to Use:** This is ideal in scenarios where the OODA loop is actively running and needs to be stopped immediately, such as during real-time decision-making simulations or strategic operations.

Prompt Example 3:

User:
```plaintext
"Stop the client"
```
Agent:
```plaintext
"Client stopped successfully!"
```
**Description:** This use case showcases the agent's ability to stop a specific client. The user instructs the agent to terminate the client (likely referring to a software client), and the agent confirms that the operation has been completed successfully.

**When to Use:** This is beneficial when a specific client program is running and needs to be halted, such as during debugging, client switching, or shutting down resources.

Prompt Example 4:

User:
```plaintext
"Stop the agent"
```
Agent:
```plaintext
"Agent stopped successfully!"
```
**Description:** This use case highlights the agent’s ability to terminate its own operations. Upon receiving the command, the agent ceases its tasks and confirms the stop action.

**When to Use:** This is useful when the user needs to pause or completely stop the AI agent from performing any tasks, especially in scenarios where further actions are no longer needed or the system requires troubleshooting.

Prompt Example 5:

User:
```plaintext
"Stop the GitHub client"
```
Agent:
```plaintext
"GitHub client stopped successfully!"
```
**Description:** This use case highlights the agent’s ability to stop the GitHub client, which could be an interface or service related to GitHub operations. The agent processes the request and terminates the GitHub client, providing a success message.

**When to Use:** This is useful when the GitHub client is actively running and needs to be halted, such as during the configuration of repositories, stopping automated pull requests, or terminating CI/CD tasks.

Prompt Example 6:

User:
```plaintext
"Stop GitHub"
```
Agent:
```plaintext
"GitHub stopped successfully!"
```

**Description:**
This use case demonstrates the agent's ability to stop all GitHub-related activities or connections. The user specifies GitHub as the target, and the agent confirms that all relevant processes have been halted.

**When to Use:**
This feature is useful in scenarios where the user wants to terminate GitHub-related processes entirely, such as stopping repository access, API integrations, or GitHub automation tools.
___
## Limitations 
Currently the GitHub plug-in can be used for small and medium repositories. We are actively integrating Decentralized Knowledge Graphs (DKG) to expand context limits and improve the relevance and accuracy of interactions, ensuring a more powerful and efficient AI experience.
